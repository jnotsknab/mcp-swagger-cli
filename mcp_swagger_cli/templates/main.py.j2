"""{{ title }} - Generated MCP Server.

This MCP server was generated from an OpenAPI specification and provides
access to the {{ title }} API via the Model Context Protocol.

Generated by: mcp-swagger-cli
Server Name: {{ server_name }}
Version: {{ version }}
Transport: {{ transport }}

{% if description %}
{{ description }}
{% endif %}
"""

import asyncio
import json
import os
from pathlib import Path
from typing import Any

import httpx
from mcp.server.fastmcp import FastMCP

# Server configuration
SERVER_NAME = "{{ server_name }}"
BASE_URL = "{{ base_url }}"

# Create the MCP server
mcp = FastMCP(
    name=SERVER_NAME,
    json_response=True,
)

# HTTP client for API calls
_http_client: httpx.AsyncClient | None = None

{% if schemas %}
# All API schemas defined once at module level
_ALL_SCHEMAS: dict[str, Any] = {{ schemas | to_python_value }}

{% endif %}

def _build_headers(extra: dict | None = None) -> dict:
    """Build HTTP headers including custom headers, API key auth, and per-operation headers."""
    headers = {}
    {% if extra_headers %}
    # Static custom headers
    {% for key, value in extra_headers.items() %}
    headers["{{ key }}"] = "{{ value }}"
    {% endfor %}
    {% endif %}
    {% if api_key_env %}
    # API key from environment variable
    api_key = os.environ.get("{{ api_key_env }}")
    if api_key:
        prefix = "{{ api_key_prefix }}"
        headers["{{ api_key_header }}"] = f"{prefix} {api_key}".strip() if prefix else api_key
    {% endif %}
    # Merge per-operation header parameters
    if extra:
        headers.update({k: v for k, v in extra.items() if v is not None})
    return headers


async def get_http_client() -> httpx.AsyncClient:
    """Get or create the HTTP client."""
    global _http_client
    if _http_client is None:
        _http_client = httpx.AsyncClient(
            base_url=BASE_URL,
            timeout=30.0,
            follow_redirects=True,
        )
    return _http_client


async def close_http_client() -> None:
    """Close the HTTP client."""
    global _http_client
    if _http_client is not None:
        await _http_client.aclose()
        _http_client = None


{% for operation in operations %}
{% set params = operation.parameters %}
{% set has_params = params | length > 0 %}
{% set has_body = operation.request_body is not none %}
{% set func_name = operation.operation_id | sanitize_name %}
{% set consumes = operation.consumes %}
{% set is_multipart = 'multipart/form-data' in consumes %}
{% set is_form = 'application/x-www-form-urlencoded' in consumes %}
{% set is_form_data = is_multipart or is_form %}


@mcp.tool()
async def {{ func_name }}(
    {%- for param in params | sort_params %}
    {{ param.name }}: {{ param.type | to_python_type }}{% if not param.required %} = None{% endif %},
    {%- endfor %}
{% if has_body and operation.request_body.schema and not is_form_data %}
    body: dict[str, Any] = {},
{% endif %}
) -> Any:
    """{{ operation.summary | escape_docstring }}
    
    {% if operation.description %}
    {{ operation.description | escape_docstring }}
    {% endif %}
    
    {% if operation.deprecated %}
    .. deprecated::
    {% endif %}
    
    {% if has_params %}
    Args:
        {%- for param in params %}
        {{ param.name }}: {{ param.description or 'Parameter' }}{% if param.required %} (required){% endif %}
        {%- endfor %}
    {% endif %}
    
    {% if has_body and not is_form_data %}
    Args:
        body: Request body (JSON)
    {% endif %}
    
    Returns:
        API response as dictionary
    """
    client = await get_http_client()
    
    {% if has_params %}
    # Build query parameters
    params = {
        {%- for param in params %}
        {% if param.in == 'query' %}
        "{{ param.name }}": {{ param.name }},
        {% endif %}
        {%- endfor %}
    }
    
    # Collect per-operation header parameters
    _op_headers = {
        {%- for param in params %}
        {% if param.in == 'header' %}
        "{{ param.name }}": {{ param.name }},
        {% endif %}
        {%- endfor %}
    }
    
    # Build URL with path parameters
    url_path = "{{ operation.path }}"
    {% for param in params %}
    {% if param.in == 'path' %}
    if {{ param.name }} is not None:
        url_path = url_path.replace("{{ '{' }}{{ param.name }}{{ '}' }}", str({{ param.name }}))
    {% endif %}
    {% endfor %}
    {% else %}
    params = None
    _op_headers = {}
    url_path = "{{ operation.path }}"
    {% endif %}
    
    {% if is_multipart %}
    # Build multipart/form-data upload
    _files = {}
    _form_data = {}
    {% for param in params %}
    {% if param.in == 'formData' %}
    {% if param.type == 'file' %}
    if {{ param.name }} is not None:
        _files["{{ param.name }}"] = {{ param.name }}
    {% else %}
    if {{ param.name }} is not None:
        _form_data["{{ param.name }}"] = {{ param.name }}
    {% endif %}
    {% endif %}
    {% endfor %}
    _request_kwargs = {}
    if _files:
        _request_kwargs["files"] = _files
    if _form_data:
        _request_kwargs["data"] = _form_data
    {% elif is_form %}
    # Build application/x-www-form-urlencoded data
    _form_data = {
        {%- for param in params %}
        {% if param.in == 'formData' %}
        "{{ param.name }}": {{ param.name }},
        {% endif %}
        {%- endfor %}
    }
    _request_kwargs = {"data": {k: v for k, v in _form_data.items() if v is not None}}
    {% elif has_body %}
    # Use body for JSON request body
    json_data = body
    _request_kwargs = {"json": json_data}
    {% else %}
    _request_kwargs = {}
    {% endif %}
    
    try:
        response = await client.request(
            method="{{ operation.method | upper }}",
            url=url_path,
            params=params,
            headers=_build_headers(_op_headers),
            **_request_kwargs,
        )
        response.raise_for_status()
        return response.json()
    except httpx.HTTPStatusError as e:
        return {
            "error": True,
            "status_code": e.response.status_code,
            "message": str(e),
            "response": e.response.text,
        }
    except Exception as e:
        return {
            "error": True,
            "message": str(e),
        }


{% endfor %}

{% if schemas %}
@mcp.resource("schema://api/schemas")
async def get_api_schemas() -> str:
    """Get all available API schemas."""
    schema_names = {{ schema_names | to_python_value }}
    return json.dumps({
        "schemas": schema_names,
        "count": len(schema_names),
    })


{% for schema_name in schema_names %}
@mcp.resource("schema://api/{{ schema_name | lower }}")
async def get_schema_{{ schema_name | sanitize_name }}() -> str:
    """Get the {{ schema_name }} schema definition."""
    return json.dumps(_ALL_SCHEMAS.get("{{ schema_name }}", {}), indent=2)


{% endfor %}
{% endif %}

{% if operations %}
@mcp.resource("api://operations")
async def get_api_operations() -> str:
    """Get list of all available API operations."""
    operations = [
        {% for operation in operations %}
        {
            "operation_id": "{{ operation.operation_id }}",
            "method": "{{ operation.method }}",
            "path": "{{ operation.path }}",
            "summary": "{{ operation.summary | escape_docstring }}",
            "tags": {{ operation.tags | to_python_value }},
        },
        {% endfor %}
    ]
    return json.dumps({
        "operations": operations,
        "count": len(operations),
    }, indent=2)


{% endif %}

def main() -> None:
    """Main entry point for the MCP server."""
    import sys
    
    # Parse transport from command line
    transport = "stdio"
    port = 8000
    
    if len(sys.argv) > 1:
        if sys.argv[1] == "--sse" or sys.argv[1] == "--http":
            transport = "sse"
        if len(sys.argv) > 2 and sys.argv[2].isdigit():
            port = int(sys.argv[2])
    
    if transport == "sse":
        # Run with SSE transport
        import uvicorn
        print(f"Starting {SERVER_NAME} on port {port}...")
        uvicorn.run(mcp.streamable_http_app, host="0.0.0.0", port=port)
    else:
        # Run with stdio transport (default)
        print(f"Starting {SERVER_NAME} with stdio transport...")
        mcp.run()


if __name__ == "__main__":
    main()
